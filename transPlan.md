# 프로젝트 마이그레이션 계획: `cloudtype.io` + Redis 도입

## 1. 목표 (Goal)
현재 프로젝트의 고질적인 서버 다운 문제(사용자당 초당 최소 1회 이상의 요청으로 인한)를 해결하고, 안정적인 서비스 운영을 위한 아키텍처를 구축합니다. 이를 위해 백엔드를 `cloudtype.io`로 이전하고, Redis를 도입하여 성능 최적화 및 부하 분산을 달성합니다.

## 2. 현재 아키텍처 (Current Architecture)
*   **백엔드**: 일반적인 백엔드 서비스 (FastAPI 기반)
*   **프론트엔드**: Netlify (React+vite)
*   **데이터베이스**: Neon DB (PostgreSQL 기반)

## 3. 문제점 (Problem Statement)
사용자당 초당 최소 1회 이상의 높은 요청 빈도로 인해 서버가 자주 다운되는 현상이 발생하고 있습니다. 이는 현재 백엔드 인프라가 이러한 부하를 감당하지 못하거나, 데이터베이스에 대한 과도한 직접 접근으로 인한 병목 현상 때문으로 추정됩니다.

## 4. 새로운 아키텍처 (New Architecture)
*   **백엔드**: `cloudtype.io` (Docker 기반 배포)
*   **프론트엔드**: Netlify (기존 유지, 백엔드 API 엔드포인트만 변경)
*   **데이터베이스**: Neon DB (기존 유지)
*   **캐싱/세션/큐**: Redis (`cloudtype.io`에서 프로비저닝)

**아키텍처 다이어그램 (개념)**:
```
[사용자] <---> [Netlify Frontend] <---> [cloudtype.io Backend (FastAPI)] <---> [Neon DB]
                                          ^
                                          |
                                          v
                                        [Redis]
```

## 5. 마이그레이션 계획 (Migration Plan)

### Phase 1: Redis 도입 및 백엔드 수정
*   **Redis 인스턴스 프로비저닝**: `cloudtype.io`에서 Redis 인스턴스를 생성하고 연결 정보를 확보합니다.
*   **백엔드 Redis 클라이언트 추가**: `backend/requirements.txt`에 `redis` 라이브러리를 추가하고 설치합니다.
*   **환경 변수 설정**: `REDIS_URL` 등 Redis 연결 정보를 환경 변수로 관리하도록 설정합니다.
*   **캐싱 전략 구현**:
    *   자주 변경되지 않거나 읽기 요청이 많은 데이터(예: 발전기 타입 정보, 업그레이드 설정, 랭킹 데이터 등)에 Redis 캐싱을 적용합니다.
    *   캐시 만료 시간(TTL) 및 데이터 변경 시 캐시 무효화 로직을 구현합니다.
*   **세션 관리 (선택)**: 현재 세션 관리 방식을 검토하고, 필요시 Redis를 세션 저장소로 활용하여 백엔드의 상태 비저장(stateless)성을 강화하고 확장성을 높입니다.
*   **Rate Limiting (선택)**: 과도한 요청으로부터 서버를 보호하기 위해 Redis 기반의 Rate Limiting 미들웨어를 구현합니다.
*   **비동기 작업 큐 (선택)**: 에너지 계산, 랭킹 업데이트 등 시간이 오래 걸리는 작업을 Redis 기반의 메시지 큐(예: Celery)를 통해 비동기적으로 처리하여 메인 요청 스레드의 부하를 줄입니다.

### Phase 2: `cloudtype.io` 배포 준비
*   **`cloudtype.io` 프로젝트 생성**: `cloudtype.io` 대시보드에서 백엔드 서비스를 위한 새 프로젝트를 생성합니다.
*   **백엔드 Dockerfile 최적화**: `backend/Dockerfile`을 검토하고, `cloudtype.io` 환경에 최적화된 형태로 수정합니다 (예: 멀티스테이지 빌드를 통한 이미지 크기 최소화, Gunicorn/Uvicorn 워커 설정).
*   **환경 변수 설정**: `cloudtype.io` 서비스 설정에서 데이터베이스 URL, Redis URL, 시크릿 키 등 필요한 모든 환경 변수를 안전하게 설정합니다.
*   **프론트엔드 설정 업데이트**: Netlify에 배포된 프론트엔드의 백엔드 API 엔드포인트를 `cloudtype.io`에서 제공하는 새 백엔드 URL로 변경합니다.

### Phase 3: 배포 및 테스트
*   **`cloudtype.io`에 백엔드 배포**: 준비된 Dockerfile을 사용하여 백엔드 애플리케이션을 `cloudtype.io`에 배포합니다. 배포 후 Redis 인스턴스와의 연결 상태를 확인합니다.
*   **프론트엔드 재배포**: 변경된 백엔드 API 엔드포인트 반영하여 Netlify 프론트엔드를 재배포합니다.
*   **기능 통합 테스트**: 모든 사용자 기능(로그인, 에너지 획득, 발전기 관리, 업그레이드, 랭킹 등)이 새 아키텍처에서 올바르게 작동하는지 철저히 테스트합니다.
*   **성능 및 부하 테스트**: 사용자당 초당 최소 1회 요청 시나리오를 시뮬레이션하는 부하 테스트를 수행합니다. Redis 캐싱의 효과, 서버 응답 시간, `cloudtype.io`의 자동 스케일링 동작 등을 모니터링하고 분석합니다.
*   **모니터링 및 로깅 설정**: `cloudtype.io`에서 제공하는 모니터링 및 로깅 도구를 설정하여 서비스 상태를 지속적으로 감시하고, 문제 발생 시 신속하게 대응할 수 있도록 알림 체계를 구축합니다.

## 6. 고려 사항 (Considerations)
*   **Redis 데이터 일관성**: 캐싱 도입 시 데이터 일관성 유지 전략(Cache-Aside, Write-Through 등)을 신중하게 선택하고 구현해야 합니다.
*   **`cloudtype.io` 리소스 제한**: `cloudtype.io`의 플랜별 리소스 제한을 확인하고, 예상되는 최대 부하에 충분한 리소스가 할당될 수 있도록 계획합니다.
*   **보안**: 환경 변수 관리, API 키 노출 방지 등 배포 환경에서의 보안을 강화합니다.
*   **롤백 계획**: 마이그레이션 중 문제가 발생할 경우를 대비하여 기존 아키텍처로의 신속한 롤백 계획을 수립합니다.
*   **FastAPI 비동기 처리**: FastAPI의 비동기 특성을 최대한 활용하여 I/O 바운드 작업을 효율적으로 처리하도록 코드를 검토합니다.

## 7. To-Do List

### Redis 도입 및 백엔드 수정
*   [ ] `cloudtype.io`에서 Redis 인스턴스 프로비저닝
*   [ ] `backend/requirements.txt`에 `redis` 라이브러리 추가
*   [ ] 백엔드 코드에 Redis 연결 설정 (환경 변수 사용)
*   [ ] 캐싱 대상 데이터 선정 (예: `generator_types`, 랭킹 데이터)
*   [ ] Redis 캐싱 로직 구현 (읽기/쓰기/무효화)
*   [ ] (선택) Redis 기반 세션 관리 구현
*   [ ] (선택) Redis 기반 Rate Limiting 미들웨어 구현
*   [ ] (선택) Redis 기반 비동기 작업 큐 (Celery) 도입 및 작업 오프로드

### `cloudtype.io` 배포 준비
*   [ ] `cloudtype.io`에 새 프로젝트 생성
*   [ ] `backend/Dockerfile` 검토 및 `cloudtype.io` 환경에 맞게 최적화
*   [ ] `cloudtype.io` 서비스 설정에서 환경 변수 (DB URL, Redis URL, 시크릿 키 등) 설정
*   [ ] 프론트엔드 (Netlify)의 백엔드 API 엔드포인트 URL 업데이트

### 배포 및 테스트
*   [ ] `cloudtype.io`에 백엔드 애플리케이션 배포
*   [ ] 프론트엔드 (Netlify) 재배포
*   [ ] 모든 기능에 대한 통합 테스트 수행
*   [ ] 성능 및 부하 테스트 수행 (초당 요청 시뮬레이션)
*   [ ] `cloudtype.io` 모니터링 및 로깅 설정
*   [ ] 오류 알림 체계 구축
